/**
 * Low-level helpers for reading / writing .resx XML files.
 */

import * as fs from "node:fs/promises";
import * as xml2js from "xml2js";

import type { ResxDataEntry, ResxDocument, ParsedResxFile } from "../types.js";
import { logger } from "./logger.js";

// ── XML codec ───────────────────────────────────────────────────────────

const xmlParser = new xml2js.Parser();

/**
 * Create an `xml2js.Builder` configured with the given line ending.
 */
function createXmlBuilder(newline: string): xml2js.Builder {
  return new xml2js.Builder({
    renderOpts: { pretty: true, indent: "  ", newline },
    xmldec: { version: "1.0", encoding: "utf-8" },
  });
}

// ── Public API ──────────────────────────────────────────────────────────

/**
 * The line ending used by .NET / Visual Studio tooling for `.resx` files.
 * CRLF is the standard convention regardless of host OS (including WSL).
 */
const RESX_DEFAULT_EOL = "\r\n";

/**
 * Detect the line-ending style used in a string.
 *
 * Returns `"\r\n"` for CRLF, `"\n"` for LF, or {@link RESX_DEFAULT_EOL}
 * when the string contains no line breaks (e.g. a single-line file).
 */
export function detectEol(content: string): string {
  if (content.includes("\r\n")) return "\r\n";
  if (content.includes("\n")) return "\n";
  return RESX_DEFAULT_EOL;
}

/**
 * Parse a `.resx` file from disk.
 *
 * Returns the parsed document together with the detected line-ending style
 * so that {@link writeResxFile} can preserve the original formatting.
 * Returns `null` when the file cannot be read or parsed.
 */
export async function parseResxFile(filePath: string): Promise<ParsedResxFile | null> {
  try {
    const content = await fs.readFile(filePath, "utf-8");
    const eol = detectEol(content);
    const document = (await xmlParser.parseStringPromise(content)) as ResxDocument;
    return { document, eol };
  } catch (error: unknown) {
    logger.error(`Failed to parse ${filePath}`, error);
    return null;
  }
}

/**
 * Serialize a document object back to XML, sort `<data>` entries
 * alphabetically by key, and write the result to disk.
 *
 * @param eol - Line ending to use. Defaults to CRLF — the standard for
 *              `.resx` files generated by .NET tooling — when not provided
 *              (e.g. when creating a brand-new file).
 */
export async function writeResxFile(
  filePath: string,
  data: ResxDocument,
  eol: string = RESX_DEFAULT_EOL,
): Promise<void> {
  sortDataEntries(data);

  // Always build with LF internally to prevent xml2js from encoding \r
  // as &#xD; inside text nodes. Convert to the desired EOL afterwards.
  const builder = createXmlBuilder("\n");
  let xml = builder.buildObject(data);

  if (eol === "\r\n") {
    xml = xml.replace(/\n/g, "\r\n");
  }

  await fs.writeFile(filePath, xml, "utf-8");
}

/**
 * Find a `<data>` entry by key name.
 */
export function findEntry(
  entries: ResxDataEntry[],
  key: string,
): ResxDataEntry | undefined {
  return entries.find((d) => d.$.name === key);
}

// ── Internal helpers ────────────────────────────────────────────────────

function sortDataEntries(data: ResxDocument): void {
  const entries = data.root.data;
  if (!Array.isArray(entries)) return;

  data.root.data = [...entries].sort((a, b) => {
    const nameA = a.$.name.toLowerCase();
    const nameB = b.$.name.toLowerCase();
    return nameA.localeCompare(nameB);
  });
}
